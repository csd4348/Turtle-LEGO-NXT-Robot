#include "AT91SAM7S256.h"
#include "display.h"
#include "spi.h"
#include <math.h>
#include <string.h>

#define   DISPLAY_HEIGHT      64        // Y pixels
#define   DISPLAY_WIDTH       100       // X pixels

#define	  CMD		0
#define	  DAT		1
#define   DISP_LINES    (DISPLAY_HEIGHT/8)

static struct {
  UBYTE   DataArray[DISPLAY_HEIGHT / 8][DISPLAY_WIDTH];
} IOMapDisplay;

UBYTE DisplayInitCommands[] =
{
  0xEB, // LCD bias: 1/9=0xEB
  0x2F, // pump control: set build-in=0x2F
  0xA4, // all pixels: off=0xA4, on=0xA5
  0xA6, // inverse: off=0xA6, on=0xA7
  0x40, // set scroll line: 0=0x40-63=0x7F
  0x81, // set Vbias potentiometer (2-byte command): 0x81 
  0x5A, //      -"-         		             : on=0x5A, off=0x00
  0xC4, // LCD mapping: regular=0xC4, row-mirror=bit 2, col-mirror=bit 3, e.g. col-mirror=0xC2
  0x27, // set temp comp.: -0.20%/C=0x27
  0x29, // panel loading: <=15nF=0x28, >15nF=0x29
  0xA0, // framerate: 76fps=0xA0, 95fps=0xA1
  0x88, // RAM address control: no wrap around+no autoincremet=0x88
  0x23, // set multiplex rate: 1:65=0x23
  0xAF  // set display: on=0xAF, off=0xAE
};

typedef struct
{
  UBYTE   ItemPixelsX;
  UBYTE   ItemPixelsY;
  UBYTE   Data[];
} __attribute__((__packed__)) FONT, ICON;

const ICON Font = {
  // each character is 6x8 pixels represented as 6 bytes, where each byte is a "column" of 8 pixels
  0x06,      // Graphics Width
  0x08,      // Graphics Height
  {/* 32 first non-printable characters */
  0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,
  /* rest printable characters */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x5F,0x06,0x00,0x00,0x07,0x03,0x00,0x07,0x03,0x00,0x24,0x7E,0x24,0x7E,0x24,0x00,0x24,0x2B,0x6A,0x12,0x00,0x00,0x63,0x13,0x08,0x64,0x63,0x00,0x30,0x4C,0x52,0x22,0x50,0x00,0x00,0x07,0x03,0x00,0x00,0x00,0x00,0x3E,0x41,0x00,0x00,0x00,0x00,0x41,0x3E,0x00,0x00,0x00,0x08,0x3E,0x1C,0x3E,0x08,0x00,0x08,0x08,0x3E,0x08,0x08,0x00,0x80,0x60,0x60,0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x60,0x60,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x00,
  0x3E,0x51,0x49,0x45,0x3E,0x00,0x00,0x42,0x7F,0x40,0x00,0x00,0x62,0x51,0x49,0x49,0x46,0x00,0x22,0x49,0x49,0x49,0x36,0x00,0x18,0x14,0x12,0x7F,0x10,0x00,0x2F,0x49,0x49,0x49,0x31,0x00,0x3C,0x4A,0x49,0x49,0x30,0x00,0x01,0x71,0x09,0x05,0x03,0x00,0x36,0x49,0x49,0x49,0x36,0x00,0x06,0x49,0x49,0x29,0x1E,0x00,0x00,0x6C,0x6C,0x00,0x00,0x00,0x00,0xEC,0x6C,0x00,0x00,0x00,0x08,0x14,0x22,0x41,0x00,0x00,0x24,0x24,0x24,0x24,0x24,0x00,0x00,0x41,0x22,0x14,0x08,0x00,0x02,0x01,0x59,0x09,0x06,0x00,
  0x3E,0x41,0x5D,0x55,0x1E,0x00,0x7E,0x11,0x11,0x11,0x7E,0x00,0x7F,0x49,0x49,0x49,0x36,0x00,0x3E,0x41,0x41,0x41,0x22,0x00,0x7F,0x41,0x41,0x41,0x3E,0x00,0x7F,0x49,0x49,0x49,0x41,0x00,0x7F,0x09,0x09,0x09,0x01,0x00,0x3E,0x41,0x49,0x49,0x7A,0x00,0x7F,0x08,0x08,0x08,0x7F,0x00,0x00,0x41,0x7F,0x41,0x00,0x00,0x30,0x40,0x40,0x40,0x3F,0x00,0x7F,0x08,0x14,0x22,0x41,0x00,0x7F,0x40,0x40,0x40,0x40,0x00,0x7F,0x02,0x04,0x02,0x7F,0x00,0x7F,0x02,0x04,0x08,0x7F,0x00,0x3E,0x41,0x41,0x41,0x3E,0x00,
  0x7F,0x09,0x09,0x09,0x06,0x00,0x3E,0x41,0x51,0x21,0x5E,0x00,0x7F,0x09,0x09,0x19,0x66,0x00,0x26,0x49,0x49,0x49,0x32,0x00,0x01,0x01,0x7F,0x01,0x01,0x00,0x3F,0x40,0x40,0x40,0x3F,0x00,0x1F,0x20,0x40,0x20,0x1F,0x00,0x3F,0x40,0x3C,0x40,0x3F,0x00,0x63,0x14,0x08,0x14,0x63,0x00,0x07,0x08,0x70,0x08,0x07,0x00,0x71,0x49,0x45,0x43,0x00,0x00,0x00,0x7F,0x41,0x41,0x00,0x00,0x02,0x04,0x08,0x10,0x20,0x00,0x00,0x41,0x41,0x7F,0x00,0x00,0x04,0x02,0x01,0x02,0x04,0x00,0x80,0x80,0x80,0x80,0x80,0x00,
  0x00,0x02,0x05,0x02,0x00,0x00,0x20,0x54,0x54,0x54,0x78,0x00,0x7F,0x44,0x44,0x44,0x38,0x00,0x38,0x44,0x44,0x44,0x28,0x00,0x38,0x44,0x44,0x44,0x7F,0x00,0x38,0x54,0x54,0x54,0x08,0x00,0x08,0x7E,0x09,0x09,0x00,0x00,0x18,0x24,0xA4,0xA4,0xFC,0x00,0x7F,0x04,0x04,0x78,0x00,0x00,0x00,0x00,0x7D,0x40,0x00,0x00,0x40,0x80,0x84,0x7D,0x00,0x00,0x7F,0x10,0x28,0x44,0x00,0x00,0x00,0x00,0x7F,0x40,0x00,0x00,0x7C,0x04,0x18,0x04,0x78,0x00,0x7C,0x04,0x04,0x78,0x00,0x00,0x38,0x44,0x44,0x44,0x38,0x00,
  0xFC,0x44,0x44,0x44,0x38,0x00,0x38,0x44,0x44,0x44,0xFC,0x00,0x44,0x78,0x44,0x04,0x08,0x00,0x08,0x54,0x54,0x54,0x20,0x00,0x04,0x3E,0x44,0x24,0x00,0x00,0x3C,0x40,0x20,0x7C,0x00,0x00,0x1C,0x20,0x40,0x20,0x1C,0x00,0x3C,0x60,0x30,0x60,0x3C,0x00,0x6C,0x10,0x10,0x6C,0x00,0x00,0x9C,0xA0,0x60,0x3C,0x00,0x00,0x64,0x54,0x54,0x4C,0x00,0x00,0x08,0x3E,0x41,0x41,0x00,0x00,0x00,0x00,0x77,0x00,0x00,0x00,0x00,0x41,0x41,0x3E,0x08,0x00,0x02,0x01,0x02,0x01,0x00,0x00,0x10,0x20,0x40,0x38,0x07,0x00}
};


UBYTE DisplayLineString[DISP_LINES][3] =
{
  { 0xB0,0x10,0x00 },
  { 0xB1,0x10,0x00 },
  { 0xB2,0x10,0x00 },
  { 0xB3,0x10,0x00 },
  { 0xB4,0x10,0x00 },
  { 0xB5,0x10,0x00 },
  { 0xB6,0x10,0x00 },
  { 0xB7,0x10,0x00 }
};

UBYTE __displayWrite(UBYTE Type , UBYTE *pData, UWORD Length){

  if(Type)
    SPIPIOSetData();
  else
    SPIPIOClearData();

  SPIWrite(pData,Length);
  return 1;

}

void DisplayInit(void){
  SPIInit();
  __displayWrite(CMD,(UBYTE*)DisplayInitCommands,sizeof(DisplayInitCommands));

}

void DisplayExit(void){
  DisplayInitCommands[6] = 0;
  DisplayInitCommands[13] = 0xAE;
  SPIWrite(DisplayInitCommands , sizeof(DisplayInitCommands))
  ;
}

void DisplayErase(void){
  //Erase all the pixels
  for(int i = 0 ; i < DISPLAY_HEIGHT/8 ; i++){
    for(int j = 0 ; j < DISPLAY_WIDTH ; j++){
      IOMapDisplay.DataArray[i][j] = 0;
    }
  }
}




void DisplayUpdateSync(void){
  // for each line of the lcd ,
  // choose address
  // send page
  
  for(int line = 0 ; line < DISP_LINES ; line ++){
  
    __displayWrite(CMD,(UBYTE*) DisplayLineString[line],3);
  
    __displayWrite(DAT,(UBYTE*)IOMapDisplay.DataArray[line], DISPLAY_WIDTH);
  }


}

void DisplayChar(UBYTE X,UBYTE Y,UBYTE Char){
  
  const UBYTE *font_ptr = &Font.Data[6 * Char];
  UBYTE col ;

  for(int i = 0 ; i < 6 ; i++){
    col = font_ptr[i];
    for(int j = 0 ; j < 8 ; j ++){
      if( (col >> j) % 2 == 0x1 ){
        DisplaySetPixel(X+i , Y+j);
      }else{
        DisplayClrPixel(X+i,Y+j);
      }
    }
  }
}

int _count_digits(int n){
  int counter = 0;

  while(n != 0){
    ++counter;
    n/=10;
  }

  return counter;
}

void DisplayNum(UBYTE X,UBYTE Y,ULONG Num){
  unsigned first_digits = (int) Num;

  if(Num == 0.0 ){
    DisplayChar(X , Y , '0' );
  }



  int count_first =  _count_digits(first_digits);

  int X_offset = X + ((count_first-1) * 6);


  for(int i = 0 ; i < count_first ; i++){
    DisplayChar(X_offset , Y , '0'+ first_digits %10);
    first_digits /= 10;
    X_offset-= 6;
  }

 


}

void DisplayString(UBYTE X,UBYTE Y,UBYTE *pString){
  size_t len = strlen(pString);

  for(size_t i = 0 ; i < len ; i++){
    DisplayChar(X + (6* i), Y , pString[i] );
  }

}

void DisplaySetPixel(UBYTE X,UBYTE Y){

  IOMapDisplay.DataArray[Y/8][X] |= 1 << (Y%8);

}

void DisplayClrPixel(UBYTE X,UBYTE Y){

    IOMapDisplay.DataArray[Y/8][X] &= ~(0 << (Y%8));

}

void DisplayLineX(UBYTE X1,UBYTE X2,UBYTE Y){

  for( int i = 0 ; i < X2-X1 ; i ++){
    DisplaySetPixel(X1+i , Y);
  }
  
}

void DisplayLineY(UBYTE X,UBYTE Y1,UBYTE Y2){
  
  for( int i = 0 ; i < Y2-Y1 ; i ++){
    DisplaySetPixel(X , Y1 + i);
  }

}


void DisplayLineXY(UBYTE X1 ,UBYTE Y1,UBYTE X2,UBYTE Y2 ){
  //using linear interpolation
  int n = 50;
  float dx = (float)(X2 - X1) / (float)(n-1);
  float dy = (float)(Y2 - Y1) / (float)(n-1);

  for(int i=0; i<n; i++) {
    float x = X1 + dx * i;
    float y = Y1 + dy * i;
    DisplaySetPixel(floor(x) , floor(y));
  }

}